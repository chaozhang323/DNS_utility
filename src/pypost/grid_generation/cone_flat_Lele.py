from util import IO_util, util_geom, util_grid
import matplotlib.pyplot as plt
import numpy as np
from gridgen.cone import flat_shock, flat_freestream, flat_combined
from gridgen import reshape, dist
from gridgen.metrics import grid_derivative as m_gd
from IC import IC_by_interp
from gridgen.polar import shift

def main():
    ###---parameters----###
    shape0 = (32,256) #(i,k)
    shape1 = (96, 256) 
    shape_out = (16, 100, 140) #(j,i,k)
    xl = -30.e-4
    yl = .12
    # skip options
    skip_shock = True#False
    skip_freestream = True#False
    # Files required to start interpolation
    dir_in = './InitBody/'
    filename_in_body = 'ConeSurfGeometry.dat'
    filename_in_shock = 'ConeShockGeometry.dat'
    dir_IC = '/usr/local/home/yl8bc/yl8bc/data/cone/run9/REST/'
    filename_in_grid_IC = 'grid.h5'
    filename_in_data_IC = 'flowdata_00100000.h5'

    # Files generated by the program
    dir_out = '/usr/local/home/yl8bc/duannas/yl8bc/data/cone/run7_2d_Lele/REST/'
    filename_out_shock = 'cone_grid_flat_shock.h5'
    filename_out_freestream = 'cone_grid_flat_freestream.h5'
    filename_out_full = 'grid.h5'
    filename_out_IC = 'flowdata_00000000.h5'
    filename_out_gd = 'gridDerivative_f.h5'
    ###---no parameters below---#
	
    if skip_shock:
        grid_tmp = IO_util.read_hdf5(dir_out+filename_out_shock)
        u_s = grid_tmp['x']
        v_s = grid_tmp['z']
    else:
        ## define wall
        body = np.loadtxt(dir_in+filename_in_body, skiprows=2)
        ## define shock
        shock = np.loadtxt(dir_in+filename_in_shock, skiprows=2)
	    ## compute shock part
        u_s,v_s = flat_shock.gridgen(shape0, body, shock, dir_out+filename_out_shock)
    
    ## compute full grid
    if skip_freestream:
        grid_tmp = IO_util.read_hdf5(dir_out+filename_out_freestream)
        u_f = grid_tmp['x']
        v_f = grid_tmp['z']
    else:
        u_f,v_f = flat_freestream.gridgen(shape1[0], xl,yl, u_s,v_s, dir_out+filename_out_freestream)
    
    ## combine grids
    u,v = flat_combined.gridgen(u_f,v_f, u_s,v_s, shape1[0]-8, shape1[0])    
    grid_out = {'x':u, 'z':v}

    ## IC
    grid_IC = IO_util.read_hdf5(dir_IC+filename_in_grid_IC)
    data_IC = IO_util.read_hdf5(dir_IC+filename_in_data_IC)
    data_out = IC_by_interp.ICgen(grid_IC, data_IC, grid_out)   
     
    ## reshape
    grid_out = reshape.reshape_by_index(shape_out[1:], grid_out)
    data_out = reshape.reshape_by_index(shape_out[1:], data_out)

    ## redistribute
    slc_axis = np.s_[:,0]
    dist_old = grid_out['x'][slc_axis].copy()
    pdist_new = dist.pdist(dist_old[0], dist_old[-1], dist_old.shape[0])
    dist_new = pdist_new.tanh(1.5, type='right')
    grid_out = reshape.redistribute(dist_new, dist_old, grid_out)
    data_out = reshape.redistribute(dist_new, dist_old, data_out)
   
    ## expand
    grid_out = reshape.expand_spanwise(shape_out[0], grid_out, span_name='y')
    data_out = reshape.expand_spanwise(shape_out[0], data_out)

    ## polar treatment
    #grid_out['z'] = shift.Colonius_shift(grid_out['z'], 2)

    ## regulate
    slc_body = np.s_[:,-1,:]
    data_out['v'][:] = 0.
    data_out['T'][slc_body] = 400.
    
    ## time
    IC_by_interp.add_time(data_out)
  
    ## inlet
    data_inlet = {key:data_out[key][:,0:1,:] for key in ['T','p','u', 'v','w']}
    
    # RANS
    data_inlet['p'][:] = 6878.1
    data_inlet['u'][:] = 1508.7#570.
    data_inlet['v'][:] = 0.
    data_inlet['w'][:] = 0.
    data_inlet['T'][:] = 202.08
    
    ## metrICs
    grid_tmp, grid_derivative = m_gd.analytically_2d(grid_out, bc_g=[0,0, 0,0, 1,0], bc_gd=[0,0,1,1,0,1])
    
    ## out
    IO_util.write_hdf5(dir_out+filename_out_full, grid_out)
    IO_util.write_hdf5(dir_out+'ghost', grid_tmp)
    IO_util.write_hdf5(dir_out+filename_out_IC, data_out)
    grid_derivative = m_gd.pack_grid_derivative(grid_derivative)
    IO_util.write_hdf5(dir_out+filename_out_gd, grid_derivative)
    IO_util.write_hdf5(dir_out+'inlet', data_inlet)
    data_out.update(grid_tmp)
    data_out.update(grid_derivative)
    IO_util.write_hdf5(dir_out+'vis', data_out)

if __name__ == '__main__':
    main()

    
