from util import IO_util, util_geom, util_grid
import matplotlib.pyplot as plt
import numpy as np
from gridgen.cone import flat_shock, flat_freestream, flat_combined
from gridgen import reshape, dist, sensor
from gridgen.metrics import grid_derivative as m_gd
from gridgen.metrics import mesh_metrics as m_mm
from IC import IC_by_interp
from gridgen.polar import shift

def main():
    ###---parameters----###
    shape0 = (32,256) #(i,k)(this is only used in orthogonal gridgen)
    shape1 = (96, 256) 
    shape_out = (16, 100, 140) #(j,i,k)(this is FINAL SHAPE)
    xl = -30.e-4 # (xl,yl) is top-left point of whole domain
    yl = .12
    # skip options(skip gridgen)
    skip_shock = False
    skip_freestream = False
    # Files required to start interpolation
    dir_in = './InitBody/'
    filename_in_body = 'ConeSurfGeometry.dat'
    filename_in_shock = 'ConeShockGeometry.dat'
    dir_IC = '/usr/local/home/yl8bc/yl8bc/data/cone/run7_Col_2d/REST/'
    filename_in_grid_IC = 'grid.h5'
    filename_in_data_IC = 'flowdata_00050000.h5'

    # Files generated by the program
    dir_out = '/usr/local/home/yl8bc/duannas/yl8bc/data/cone/run11_GCL/REST/'
    filename_out_shock = 'cone_grid_flat_shock.h5'
    filename_out_freestream = 'cone_grid_flat_freestream.h5'
    filename_out_full = 'grid.h5'
    filename_out_IC = 'flowdata_00000000.h5'
    filename_out_gd = 'gridDerivative_f.h5'
    filename_out_mi = 'metric_identities_f.h5'
    ###---no parameters below---#
	
    if skip_shock:
        grid_tmp = IO_util.read_hdf5(dir_out+filename_out_shock)
        u_s = grid_tmp['x']
        v_s = grid_tmp['z']
    else:
        ## define wall
        body = np.loadtxt(dir_in+filename_in_body, skiprows=2)
        #poly = np.polyfit(body[21:35,0], body[21:35,1], 10)
        #body[21:35,1] = np.polyval(poly, body[21:35,0])
        ## define shock
        shock = np.loadtxt(dir_in+filename_in_shock, skiprows=2)
        ## compute shock part
        u_s,v_s = flat_shock.gridgen(shape0, body, shock, dir_out+filename_out_shock)
    
    ## compute full grid
    if skip_freestream:
        grid_tmp = IO_util.read_hdf5(dir_out+filename_out_freestream)
        u_f = grid_tmp['x']
        v_f = grid_tmp['z']
    else:
        u_f,v_f = flat_freestream.gridgen(shape1[0], xl,yl, u_s,v_s, dir_out+filename_out_freestream)
    
    ## combine grids
    u,v = flat_combined.gridgen(u_f,v_f, u_s,v_s, shape1[0]-8, shape1[0])    
    grid_out = {'x':u, 'z':v}

    ## IC
    grid_IC = IO_util.read_hdf5(dir_IC+filename_in_grid_IC)
    data_IC = IO_util.read_hdf5(dir_IC+filename_in_data_IC)
    data_out = IC_by_interp.ICgen(grid_IC, data_IC, grid_out)   
     
    ## reshape in 2d
    grid_out = reshape.reshape_by_index(shape_out[1:], grid_out)
    data_out = reshape.reshape_by_index(shape_out[1:], data_out)

    ## redistribute
    slc_axis = np.s_[:,0]
    dist_old = grid_out['x'][slc_axis].copy()
    pdist_new = dist.pdist(dist_old[0], dist_old[-1], dist_old.shape[0])
    dist_new = pdist_new.tanh(2.5, type='right')
    grid_out = reshape.redistribute(dist_new, dist_old, grid_out)
    data_out = reshape.redistribute(dist_new, dist_old, data_out)
   
    ## expand
    grid_out = reshape.expand_spanwise(shape_out[0], grid_out, dim_new=1, span_name='y')
    data_out = reshape.expand_spanwise(shape_out[0], data_out, dim_new=1)

    ## polar treatment
    grid_out['z'] = shift.Colonius_shift(grid_out['z'], 2)

    ## regulate
    slc_body = np.s_[-1,:,:]
    data_out['v'][:] = 0.
    data_out['T'][slc_body] = 400.
    
      
    ## inlet
    data_inlet = {key:data_out[key][0:1,:,:] for key in ['T','p','u', 'v','w']}
    
    # RANS
    data_inlet['p'][:] = 6878.1
    data_inlet['u'][:] = 1508.7
    data_inlet['v'][:] = 0.
    data_inlet['w'][:] = 0.
    data_inlet['T'][:] = 202.08
    
    ## ducros
#    ducros = sensor.ducros(data_out['u'], data_out['v'], data_out['w'], grid_out, \
#                           u_inf=1508., delta_in = 0.125)
#    dist_old = grid_out['x'][:,0,0].copy()
#    dist_new = dist.ptrans(dist_old).expo(.5, 50)
#    grid_out = reshape.redistribute(dist_new, dist_old, grid_out, dim=0)
#    data_out = reshape.redistribute(dist_new, dist_old, data_out, dim=0)
   

    ## metrICs
    grid_tmp, grid_derivative = m_gd.analytically_2d(grid_out, bc_g=[0,0,0,0,0,0], bc_gd=[0,0, 1,1, 0,1])
    #grid_tmp, grid_derivative = m_gd.native(grid_out, bc_g=[0,0,0,0,0,0], bc_gd=[1,1, 0,0, 0,1])
    
    mm, Ji = m_mm.compute_mesh_metrics(grid_derivative)
    I = m_mm.compute_metric_identities(mm, Ji)

    ## transpose
    grid_out = {key:np.swapaxes(value,0,1) for key,value in grid_out.items()}
    data_out = {key:np.swapaxes(value,0,1) for key,value in data_out.items()}
    data_inlet = {key:np.swapaxes(value,0,1) for key,value in data_inlet.items()}
    
    grid_derivative = np.swapaxes(grid_derivative, 2,3)
    mm = np.swapaxes(mm, 2,3)
    I = np.swapaxes(I, 1,2)
    ducros = np.swapaxes(ducros, 0,1)

    ## time
    IC_by_interp.add_time(data_out)

    ## out
    IO_util.write_hdf5(dir_out+filename_out_full, grid_out)
    IO_util.write_hdf5(dir_out+filename_out_IC, data_out)
    grid_derivative = m_gd.pack_grid_derivative(grid_derivative)
    IO_util.write_hdf5(dir_out+filename_out_gd, grid_derivative)
    I = m_mm.pack_metric_identities(I)
    IO_util.write_hdf5(dir_out+filename_out_mi, I)
    IO_util.write_hdf5(dir_out+'inlet', data_inlet)
    data_out.update(grid_out)
    data_out.update(grid_derivative)
    data_out.update({'ducros':ducros})
    IO_util.write_hdf5(dir_out+'vis', data_out)

if __name__ == '__main__':
    main()

    
