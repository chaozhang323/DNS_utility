from util import IO_util, util_interp
import matplotlib.pyplot as plt
import numpy as np
from util import mm
#print mm.modmetrics.__doc__

def stretch_expo(x, a):
    x0 = x[0]
    xm = x[-1]
    y = (np.exp(a*(x-x0)/(xm-x0)) - 1.) / (np.exp(a)-1.) * (xm-x0) + x0
    return y

def stretch_tanh(x, a, type='both'):
    x0 = x[0]
    xm = x[-1]
    L = xm-x0
    if type=='both':
        y = np.tanh(a*(2./L*(x-x0)-1.)) / np.tanh(a) *L*0.5 + (x0+xm)*0.5
    elif type=='left':
        y = np.tanh(a*(1./L*(x-x0)-1.)) / np.tanh(a) *L + xm
    elif type=='right':
        y = np.tanh(a*(1./L*(x-x0)   )) / np.tanh(a) * L + x0
    
    return y

def stretch_func(x):
    x[:] = stretch_tanh(x, 3., type='right')
    I_inner = x>-0.0004
    num_inner = np.sum(I_inner)
    I_outer = np.logical_not(I_inner)
    x[I_inner] = stretch_tanh(x[I_inner], 1.4)    
    x[num_inner-1:] = stretch_tanh(x[num_inner-1:], 1.4, type='right')
    #x[:] = stretch_tanh(x, 2., type='left')
    return

if __name__ == '__main__':
    ###---parameters----###
    # Files required to start interpolation
    # "filename_fluent": old file that contains Fluent data in .dat format
    shape = (32, 100, 140)
    dir_in = '../../data/grids/'
    filename_in = 'cone_grid_flat_part2.h5'
    # Files generated by the program
    dir_out = '/usr/local/home/yl8bc/duannas/yl8bc/data/cone/run3_polar/REST/' 
    filename_out = 'grid'

    ## stack those grids
    grid_in, names = IO_util.read_hdf5(dir_in+filename_in)
    
    ## 
    x0 = grid_in['x'][0,0]
    xm = grid_in['x'][-1,0]
    dist_bot = grid_in['x'][:,0].copy()
    distribution = np.linspace(x0, xm, grid_in['x'].shape[0])
    #distribution =  grid_in['x'][:,0]
    #stretch_func(distribution)
    
    ## interp by distribution
    for key,var in grid_in.iteritems():
        for n in range(0, grid_in['x'].shape[1]):
            grid_in[key][:,n] = np.interp( distribution, dist_bot, var[:,n])
    
    ## intep to new shape
    grid1 = {}
    for key,var in grid_in.iteritems():
        grid1[key] = np.zeros((grid_in['x'].shape[0],shape[2]))
        for n in range(0, grid_in['x'].shape[0]):
            grid1[key][n,:] = util_interp.interp_by_index(var[n,:], shape[2])
    grid2 = {}
    for key,var in grid1.iteritems():
        grid2[key] = np.zeros(shape[1:])
        for n in range(0, shape[2]):
            grid2[key][:,n] = util_interp.interp_by_index(var[:,n], shape[1])

    #grid2 = grid_in

    x = grid2['x']
    z = grid2['z']
    ## fix axis boundary
    if True:
        L = z[:,-1] 
        d = z[:,1]
        r = L / (L+0.5*d)
        r = r[:,np.newaxis]
        z = L[:,np.newaxis]*(1.-r)   + r*z
        #x[:,0] = x[:,1]
    
    ## expand to 3d
    grid2['x'] = x
    grid2['z'] = z
    for key, var in grid2.iteritems():
        grid2[key] =  np.repeat(var[np.newaxis,:,:], shape[0], axis=0)

    #x = np.repeat(x[np.newaxis,:,:], shape[0], axis=0)
    #z = np.repeat(z[np.newaxis,:,:], shape[0], axis=0)
    y = np.linspace(0., 2.*np.pi, shape[0]+1)[:-1]
    y = np.repeat(y[:,np.newaxis], shape[1], axis=1)
    y = np.repeat(y[:,:,np.newaxis], shape[2], axis=2)

    ## out
    grid = {}
    #grid['x'] = x
    #grid['z'] = z
    grid2['y'] = y
    grid2['w'][:,:,:] = 0.
    #mm = mm.modmetrics.mm_calculator_2d(u, v)
    #grid['dxdi'] = mm[0,0,:,:]
    #grid['dxdj'] = mm[0,1,:,:]
    #grid['dydi'] = mm[1,0,:,:]
    #grid['dydj'] = mm[1,1,:,:]
    
    ## output
    grid = {key:grid2[key] for key in ['x','y','z']}
    data = {key:grid2[key] for key in ['T','p','u', 'v','w']}
    data['time'] = np.array([0.])
    data_inlet = {key:grid2[key][:,0:1,:] for key in ['T','p','u', 'v','w']}
    
    
    IO_util.write_hdf5(dir_out+filename_out, grid)
    #IO_util.write_hdf5(dir_out+'flowdata_00000000', data)
    IO_util.write_hdf5(dir_out+'inlet', data_inlet)
    IO_util.write_hdf5(dir_out+'vis', grid2)
