import sys
from os import path
sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) )
from util import IO_util, util_tp
import matplotlib.pyplot as plt
import numpy as np
from numpy import f2py
with open("/usr/local/home/yl8bc/Nic/PH/post/grid_generation/gridgen.f90") as sourcefile:
    sourcecode = sourcefile.read()
f2py.compile(sourcecode, modulename='gridgen', extension='.f90', extra_args='--f90flags=''-fopenmp'' -lgomp')
import gridgen

def normalized_flipped(u, nx):
    uscale = u[-1] - u[0]
    u -= u[0]
    u /= uscale
    u = np.flip(u, axis=0)
    u = 1. - u
    nx0 = u.shape[0]
    u = np.interp( np.linspace(0.,nx0-1.,nx), np.linspace(0.,nx0-1.,nx0), u)

    return u

def Billig_wedge_shock(M, R, beta, y):
    delta = R*0.386*np.exp(4.67/M**2)
    Rc = R*1.386*np.exp(1.8/np.power(M-1.,0.75))
    tan_beta = np.tan(beta)
    x = R + delta - Rc/tan_beta**2*(np.sqrt(1+y**2*tan_beta**2/Rc**2) - 1.)
    return x

def Billig_wedge_shock_inverse(M, R, beta, x):
    delta = R*0.386*np.exp(4.67/M**2)
    Rc = R*1.386*np.exp(1.8/np.power(M-1.,0.75))
    tan_beta = np.tan(beta)
    y = np.sqrt( ( ( (x-R-delta)/(-Rc/tan_beta**2)+1. )**2 - 1.)*Rc**2/tan_beta**2 )
    return y

def Billig_wedge(R, theta, y):
    Inose = abs(y) < np.cos(theta)*R
    Ibody = np.logical_not( Inose )
    x = np.zeros_like(y)
    x[Inose] = np.sqrt(R**2-y[Inose]**2)
    x[Ibody] = -np.abs( y[Ibody]/np.tan(theta) ) + R/np.sin(theta)
    return x

if __name__ == '__main__':
    ###---parameters----###
    # Files required to start interpolation
    # "filename_fluent": old file that contains Fluent data in .dat format
    dir_in = '/usr/local/home/yl8bc/duannas/'
    filename_fluent = 'jhyt7/Acoustics/HLB/Interp_Fluent_DNS/nozzle2d_fluent.dat'
    filename_outlet = 'Test_Incompact3d/HLB_Nozzle/AcousticZgrid_k500.dat'
    # Files generated by the program
    # "filename_output_tecplot": new file that contains interpolated data in Tecplot format(.plt)
    # "filename_output_hdf5": new file that contains interpolated data in HDF5 format(.h5)
    # "filename_output_ascii": new file that contains interpolated data in plain text format
    dir_out = '/usr/local/home/yl8bc/Nic/PH/post/HLB_interp/'
    filename_output_hdf5 = 'wedge_grid'
    ###---no parameters below---#
    # print gridgen.cm_gridgen.__doc__
    #----read fluent grid & data-----!
    R = 1.
    M = 6.
    theta_c = 20./180.*np.pi
    beta =  24.1242779/180.*np.pi

    y_bot = np.linspace(4.,-4.0, 2**16)
    x_bot = Billig_wedge(R, theta_c, y_bot)
    # y_bot[0] = y_bot[2**7]
    # y_bot[-1] = y_bot[-1-2**7]
    x0 = x_bot[0]
    y0 = y_bot[0]

    x1 = x0
    y1 = Billig_wedge_shock_inverse(M,R,beta, x1)
    y_top = np.linspace(y1,-y1, 2**16)
    x_top  = Billig_wedge_shock(M, R, beta, y_top)


    # plt.plot(x_bot,y_bot)
    # plt.plot(x_top,y_top)
    # plt.show()


    shape = (256,64)
    u = np.zeros(shape)
    v = np.zeros(shape)


    choice_left = np.stack([np.linspace(x0,x1,2**16),
                            np.linspace(y0,y1,2**16)], axis=1)

    choice_right = np.stack([np.linspace(x0,x1,2**16),
                            np.linspace(-y0,-y1,2**16)], axis=1)

    choice_bottom = np.stack([x_bot,
                              y_bot], axis=1)

    choice_top = np.stack([x_top,y_top], axis=1)

    # choice_left = gridgen.cm_gridgen.refine_boundary(choice_left)
    # choice_right = gridgen.cm_gridgen.refine_boundary(choice_right)
    # for i in range(9):
    #     choice_bottom = gridgen.cm_gridgen.refine_boundary(choice_bottom)
    #     choice_top = gridgen.cm_gridgen.refine_boundary(choice_top)
    # print choice_bottom.shape, choice_top.shape
    # print choice_top


    start_over = True
    if start_over:
        #IC
        idx_left, u[0,:],v[0,:] = gridgen.cm_gridgen.init_index(choice_left, shape[1], 1)
        idx_right, u[-1,:],v[-1,:] = gridgen.cm_gridgen.init_index(choice_right, shape[1], 1)
        idx_bottom, u[:,0],v[:,0] = gridgen.cm_gridgen.init_index(choice_bottom, shape[0], 1)
        idx_top, u[:,-1],v[:,-1] = gridgen.cm_gridgen.init_index(choice_top, shape[0], 1)
        u,v = gridgen.cm_gridgen.init_tfi(u, v)
        grid = {'x':u, 'y':v}
        IO_util.write_hdf5(dir_out+filename_output_hdf5, grid)
    else:
        idx_left = np.load('idx_left.npy')
        idx_right = np.load('idx_right.npy')
        idx_bottom = np.load('idx_bottom.npy')
        idx_top = np.load('idx_top.npy')
        grid, vars_name = IO_util.read_hdf5(dir_out+filename_output_hdf5+'.h5')
        u = grid['x']
        v = grid['y']

    iloop = True
    while iloop:

        u,v,idx_left,idx_right,idx_bottom,idx_top,iconverge = gridgen.cm_gridgen.compute_grid(u,v,idx_left,idx_right,
                                                                                              idx_bottom,idx_top,
                                                                                              choice_left,choice_right,
                                                                                              choice_bottom,choice_top, 1e-8, .0, 100,
                                                                                              np.array([0,0,0,0],dtype=int),
                                                                                              np.array([0,0,0,0],dtype=int))
        #iconverge = 1
        np.save('idx_left', idx_left)
        np.save('idx_right', idx_right)
        np.save('idx_bottom', idx_bottom)
        np.save('idx_top', idx_top)
        grid = {'x':u, 'y':v}
        IO_util.write_hdf5(dir_out+filename_output_hdf5, grid)
        if iconverge==1:
            print 'Converged!'
            iloop=False

